/************************************************************************* *  Compilation:  javac Biconnected.java *  Execution:    java Biconnected V E *  Dependencies: Graph.java GraphGenerator.java * *  Identify articulation points and print them out. *  This can be used to decompose a graph into biconnected components. *  Runs in O(E + V) time. * *  From S&W, with alterations for an assignment. * * $ java-algs4 Biconnected 8 8 88888888 * 8 vertices, 8 edges  * 0: 1 4 3  * 1: 0 3  * 2: 6  * 3: 7 5 1 0  * 4: 0 5  * 5: 3 4  * 6: 2  * 7: 3  *  * No vs in cycles: 5 * Set of vertices in cycles: { 0, 1, 3, 4, 5 } *  * Articulation points * ------------------- * 3 * $  *************************************************************************/import edu.princeton.cs.algs4.StdOut;import edu.princeton.cs.algs4.Stack;import edu.princeton.cs.algs4.StdRandom;import edu.princeton.cs.algs4.Graph;import edu.princeton.cs.algs4.SET;public class Biconnected {    private int[] low;    private int[] pre;    private int cnt;    // private int bridges;    private boolean[] articulation;    private Stack<Integer> stack;    private SET<Integer> inCycle;    public Biconnected(Graph G) {        low = new int[G.V()];        pre = new int[G.V()];        articulation = new boolean[G.V()];        for (int v = 0; v < G.V(); v++) low[v] = -1;        for (int v = 0; v < G.V(); v++) pre[v] = -1;	stack = new Stack<>();	inCycle = new SET<>();                for (int v = 0; v < G.V(); v++)            if (pre[v] == -1) {		stack.push(v);                dfs(G, v, v);	    }    }    private void dfs(Graph G, int u, int v) {        int children = 0;        pre[v] = cnt++;        low[v] = pre[v];        for (int w : G.adj(v)) {            if (pre[w] == -1) {                children++;		stack.push(w);                dfs(G, v, w);                // update low number                low[v] = Math.min(low[v], low[w]);                // non-root of DFS is an articulation point if low[w] >= pre[v]                if (low[w] >= pre[v]) {		    SET<Integer> block = new SET<>();		    if (u != v)			articulation[v] = true;		    int x;		    do {			x = stack.pop();			block.add(x);		    } while (x != w);		    block.add(v);		    if (block.size() > 2) 			for (int z : block) 			    inCycle.add(z);		}            }            // update low number - ignore reverse of edge leading to v            else if (w != u)                low[v] = Math.min(low[v], pre[w]);        }        // root of DFS is an articulation point if it has more than 1 child        if (u == v && children > 1)            articulation[v] = true;    }    public int noInCycle() {	return inCycle.size();    }    public SET<Integer> vsInCycle() {	return inCycle;    }    // is vertex v an articulation point?    public boolean isArticulation(int v) { return articulation[v]; }    // test client    public static void main(String[] args) {        int V = Integer.parseInt(args[0]);        int E = Integer.parseInt(args[1]);	long seed = Long.parseLong(args[2]);	StdRandom.setSeed(seed);        Graph G = GraphGenerator.simple(V, E);        StdOut.println(G);        Biconnected bic = new Biconnected(G);	StdOut.println("No vs in cycles: " + bic.noInCycle());	StdOut.println("Set of vertices in cycles: " + bic.vsInCycle());	        // print out articulation points        StdOut.println();        StdOut.println("Articulation points");        StdOut.println("-------------------");        for (int v = 0; v < G.V(); v++)            if (bic.isArticulation(v)) StdOut.println(v);    }}